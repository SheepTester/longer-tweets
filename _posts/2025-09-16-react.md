---
layout: post
title: React is fine
description: Todo
date: 2025-09-16
tags:
  - programming
  - html5
hidden: true
---

The JavaScript ecosystem is notorious for birthing a new web framework every day, and React apps are notorious for consuming memory, producing large builds, and growing ugly in large codebases. Yet despite the plentiful alternatives purporting to solve each of React's downfalls, React apps are ubiquitous today, found pretty much on every web page beyond the simplest static sites, and used by almost every front-end team in companies. This is partly because it is difficult to switch to other frameworks when React benefits from its network effects.

Personally, I think React is fine. It offers a compelling strength that justifies why you wouldn't just use vanilla JavaScript, and I don't think its weaknesses are disastrous to call the React monopoly a terrible tragedy.

In this Longer Tweet, I yap a bunch about [why I switched to React in the first place](#my-history-with-react), then I go over some minor pain points I have with React.

## My history with React

<!-- Having used vanilla JavaScript for a good portion of my time playing around with web development, I -->

For a good portion of the time I've spent making websites, I've used vanilla JavaScript and direct DOM manipulation. For example, to add a heading to the page, I'd do

```js
const heading = document.createElement('h1')
heading.textContent = 'Hello!'
document.body.append(heading)
```

or perhaps

```js
document.body.append(
  Object.assign(document.createElement('h1'), {
    textContent: 'Hello!'
  })
)
```

I was making many small self-contained web pages, so I tried to avoid frameworks where possible out of practical concerns.

Many frameworks start their tutorials under the assumption that you will be making one large production-ready codebase, so they'll recommend some bloated template like create-react-app[^1]---mind you, I was dealing with this around 2016, when most web frameworks were just starting to mature. While I could tolerate each web page living in its own subdirectory, each template would also offer its own package.json, and with that, its own several gigabytes of node_modules. pnpm was too new around that time, and the laptop I was working on was persistently short on storage, often with less than 1 GB left. If I made a React project for every little web project I started, I would quickly rack up gigabytes of disk usage, probably from Webpack alone.

[^1]: I know create-react-app is deprecated, but my point still stands. There's create-next-app, `sv create`, create-vue, etc.

<!-- Around that time, the only framework I knew was React. -->

### Reactive

To this day, I never learned React formally; I only figured it out by piecing through [scratch-gui](https://github.com/llk/scratch-gui)'s code, with its class components, Redux reducers, PropTypes, higher order components---all concepts that were deprecated by the time I got to author my own React code. But I got the gist of how it worked and more importantly, why it was used.

To that end, instead of learning to use React, I made my own knock-off, cheekily named [Reactive](https://github.com/Orbiit/gunn-web-app/blob/master/js/dumb-reactive.js). I declaratively defined the HTML in arrays---effectively a virtual DOM---then the library compares the declared elements to the previous state and makes corresponding changes to the real DOM. This was for rendering bell schedules in my [Unofficial Gunn Web App (UGWA)](https://orbiit.github.io/gunn-web-app/), replacing my previous 9th-grade approach of generating an HTML string and setting `innerHTML`.

I made Reactive largely because I felt that React and React DOM were bloated and would increase the bundle size of my app. However, it demonstrated one strength of React: it's transparently just a library, so there's no compiler that could magically transform my code into something beyond my grasp.[^2] When I use React, I have a rough idea of how it's implemented under the hood.

[^2]: I know the React Compiler exists now, but my point still stands. The React Compiler is meant to replicate the behaviors of the existing library, which presumably means that once released, you'd still be able to use the library without the compiler.

<!-- Indeed, you don't need to have a build step for React at all -->

### Next.js

Outside of [modding Scratch](https://sheeptester.github.io/scratch-gui/), I never really wrote my own React code until 2020, during Covid. [Serena]https://acrantel.github.io/ invited me to participate in some week-long online hackathon, where we made [some health project](https://devpost.com/software/fiitshare). Ultimately, I don't think we won anything, but it was the first time I had to write my own React components from scratch.

The project was quite different from scratch-gui. Instead of Scratch's plain React, we used Next.js. It was interesting to see how simple components really were; there was no need to create a container for every component, like what seemed to be [the case for Scratch](https://github.com/scratchfoundation/scratch-gui/tree/develop/src/containers). Yet, at the same time, it still felt like quite a pain to create a new component, since each time I wanted a new component, not only did I have to copy and paste the component template, but I also had to link it with a CSS module. Compared to my vanilla JavaScript projects, where I typically lump all my CSS into one file, this felt like a lot of bloat.

One curiosity from Next.js was how some file names had special meanings. In the pages/api/ folder, you can just create a JavaScript file that exports an HTTP request handler, and without importing it anywhere, it magically ends up as an API route on the backend. You can even use placeholders in the file name, like `[groupid].js`, to provide parameters. To me, this file-based routing felt like the compiler was holding my hand too much. The Next.js framework had magically set everything up for me, but it felt like I would quickly run into a use case not supported well by the framework, and that the framework would produce more bloat than my project would need.

This was one of my first times collaborating on a project with other people. As a high school student, I wasn't confident about how a proper project should be structured. For instance, I would often see projects divided up into src/, assets/, docs/, etc., but I couldn't find some definitive guide on how they should be used in a new project. So using React felt like the proper thing to use for a project, and in my [next collaborative project](https://github.com/anematode/velar)---a UI for our friend's graphing calculator---we opted to use create-react-app.[^3]

[^3]: It isn't worth noting, but a few months later I also worked on [Clustr](https://github.com/GHSClubs/Clustr-Web-App), which uses create-react-app. I feel like the lore is kind of funny. Basically, some people from my high school were working on a startup---one of them is a child of a [tech bro](https://en.wikipedia.org/wiki/Bart_Decrem)---and wanted me to help them with the web version of their app. It's just a wrapper around the spreadsheet of school clubs, since the school year was remote, but they managed to get the school admins to advertise it. Nonetheless, while I was implementing their design, I happened to also be updating the clubs list in UGWA---their direct competitor. UGWA's club directory had more information, including the clubs' promo videos, and was easier to search, if I do say so myself. Tragically, UGWA was [only acknowledged after it had shut down](https://midpenpost.org/2022/05/26/web-app-of-the-titans-the-story-of-gunns-schedule-app/).

Another hurdle that I was dealing with at the same time were bundlers. Scratch used Webpack, which was bloated and full of dependencies. I had the impression that Rollup was better, maybe because it was leaner. I'm not sure where I got this impression from; maybe it was just because my friend was using it for [his projects](https://github.com/anematode/grapheme).

### Personal projects

uxdy

- strict project layout
- build system

react benefit is reactivity/declarativeness

since i was able to implement it myself for UGWA, i think react is fairly transparent; you have a rough idea of what's going on under the hood

haven't looked out for frameworks much because of the above, but these are what i should look out for:

react annoyances:

- no function initializer for use ref like use state
- sometimes use effect needs latest value of state without running use effect again (solution is use ref but then you have state and ref if you want it to affect rendering too)
- hard to keep track of what is or should be memoized for hook dependencies
- (elm issue too) modifying state in a deeply nested object is verbose
- date Intl API results in hydration errors
- date.now and local storage are technically impure but it sucks that they need to be initialized in a use effect
- no built in class list
